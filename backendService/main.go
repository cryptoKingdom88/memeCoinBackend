package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"backendService/config"
	"backendService/handlers"
	"backendService/kafka"
	"backendService/logging"
	"backendService/models"
	"backendService/websocket"

	"github.com/gin-gonic/gin"
	ginSwagger "github.com/swaggo/gin-swagger"
	swaggerFiles "github.com/swaggo/files"
	_ "backendService/docs" // This will be generated by swag
)

// @title Backend WebSocket Service API
// @version 1.0
// @description A WebSocket server that bridges Kafka data streams with frontend clients
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name MIT
// @license.url https://opensource.org/licenses/MIT

// @host localhost:8080
// @BasePath /
// @schemes http ws

// HealthResponse represents the health check response
type HealthResponse struct {
	Status      string                 `json:"status" example:"healthy"`
	Clients     int                    `json:"clients" example:"5"`
	Channels    []string               `json:"channels" example:"dashboard"`
	HubStatus   map[string]interface{} `json:"hub_status"`
	Timestamp   string                 `json:"timestamp"`
}

// performHealthCheck performs a health check for Docker health check
func performHealthCheck() {
	client := &http.Client{
		Timeout: 5 * time.Second,
	}
	
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	
	resp, err := client.Get(fmt.Sprintf("http://localhost:%s/health", port))
	if err != nil {
		fmt.Printf("Health check failed: %v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != http.StatusOK {
		fmt.Printf("Health check failed with status: %d\n", resp.StatusCode)
		os.Exit(1)
	}
	
	fmt.Println("Health check passed")
	os.Exit(0)
}

// healthCheck godoc
// @Summary Health check endpoint
// @Description Get the current health status of the WebSocket service
// @Tags health
// @Accept json
// @Produce json
// @Success 200 {object} HealthResponse
// @Failure 503 {object} HealthResponse
// @Router /health [get]
func healthCheck(hubManager *websocket.HubManager) gin.HandlerFunc {
	logger := logging.GetLogger().WithComponent("health-check")
	
	return func(c *gin.Context) {
		defer func() {
			if r := recover(); r != nil {
				logger.WithField("panic", r).Error("Panic in health check")
				c.JSON(http.StatusInternalServerError, HealthResponse{
					Status:    "error",
					Clients:   0,
					Channels:  []string{},
					HubStatus: map[string]interface{}{"error": "health check panic"},
					Timestamp: time.Now().UTC().Format(time.RFC3339),
				})
			}
		}()

		hubStatus := hubManager.GetHealthStatus()
		status := "healthy"
		statusCode := http.StatusOK
		
		// Determine overall health status
		if !hubManager.IsRunning() {
			status = "unhealthy"
			statusCode = http.StatusServiceUnavailable
		} else if hubManager.GetClientCount() == 0 {
			status = "degraded"
		}

		response := HealthResponse{
			Status:    status,
			Clients:   hubManager.GetClientCount(),
			Channels:  hubManager.GetActiveChannels(),
			HubStatus: hubStatus,
			Timestamp: time.Now().UTC().Format(time.RFC3339),
		}

		c.JSON(statusCode, response)
	}
}

func main() {
	// Check for health check flag
	if len(os.Args) > 1 && os.Args[1] == "--health-check" {
		performHealthCheck()
		return
	}

	// Load configuration
	cfg := config.Load()
	
	// Initialize structured logging
	logging.InitFromEnv()
	logger := logging.GetLogger()
	
	logger.WithFields(map[string]interface{}{
		"port":                cfg.Port,
		"kafka_brokers":       cfg.KafkaBrokers,
		"kafka_consumer_group": cfg.KafkaConsumerGroup,
		"log_level":           cfg.LogLevel,
	}).Info("Starting backend WebSocket service")
	
	// Initialize WebSocket hub
	hub := models.NewHub()
	hubManager := websocket.NewHubManager(hub)
	
	// Start hub manager in a goroutine
	go hubManager.Run()
	logger.Info("WebSocket hub manager started")
	
	// Initialize Kafka consumer manager
	consumerManager := kafka.NewConsumerManager(hubManager, cfg)
	
	// Start Kafka consumers
	if err := consumerManager.Start(); err != nil {
		logger.WithField("error", err).Fatal("Failed to start Kafka consumers")
	}
	logger.Info("Kafka consumers started successfully")
	
	// Initialize WebSocket handler
	wsHandler := handlers.NewWebSocketHandler(hub)
	
	// Setup Gin router
	router := gin.Default()
	
	// WebSocket endpoint
	router.GET("/ws", wsHandler.WebSocketUpgrade)
	
	// Health check endpoint
	router.GET("/health", healthCheck(hubManager))
	
	// Swagger documentation
	router.GET("/docs/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	
	// WebSocket API documentation
	router.Static("/websocket-docs", "./docs")
	
	// Root redirect to documentation
	router.GET("/", func(c *gin.Context) {
		c.Redirect(http.StatusMovedPermanently, "/docs/")
	})
	
	// Create HTTP server
	server := &http.Server{
		Addr:    ":" + cfg.Port,
		Handler: router,
	}
	
	// Start server in a goroutine
	go func() {
		logger.WithField("port", cfg.Port).Info("Starting HTTP server")
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			logger.WithField("error", err).Fatal("Server failed to start")
		}
	}()
	
	// Wait for interrupt signal to gracefully shutdown the server
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	
	// Also listen for other signals that might indicate problems
	crash := make(chan os.Signal, 1)
	signal.Notify(crash, syscall.SIGQUIT, syscall.SIGABRT)
	
	select {
	case sig := <-quit:
		logger.WithField("signal", sig).Info("Received shutdown signal")
	case sig := <-crash:
		logger.WithField("signal", sig).Warn("Received crash signal")
	}
	
	logger.Info("Initiating graceful shutdown...")
	
	// Create a deadline for shutdown
	shutdownTimeout := 30 * time.Second
	ctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
	defer cancel()
	
	// Shutdown components in order with individual timeouts
	shutdownComplete := make(chan bool, 1)
	shutdownErrors := make(chan error, 3)
	
	go func() {
		defer func() {
			if r := recover(); r != nil {
				logger.WithField("panic", r).Error("Panic during shutdown")
				shutdownErrors <- fmt.Errorf("panic during shutdown: %v", r)
			}
			shutdownComplete <- true
		}()
		
		// Stop accepting new connections first
		logger.Info("Stopping HTTP server from accepting new connections")
		if err := server.Shutdown(ctx); err != nil {
			logger.WithField("error", err).Error("Error during HTTP server shutdown")
			shutdownErrors <- fmt.Errorf("HTTP server shutdown error: %v", err)
		}
		
		// Stop Kafka consumers
		logger.Info("Stopping Kafka consumers")
		consumerManager.Stop()
		
		// Shutdown WebSocket hub and disconnect all clients
		logger.Info("Shutting down WebSocket hub")
		hubManager.Shutdown()
		
		logger.Info("All components shutdown successfully")
	}()
	
	// Wait for shutdown to complete or timeout
	select {
	case <-shutdownComplete:
		logger.Info("Graceful shutdown completed successfully")
	case <-ctx.Done():
		logger.Warn("Shutdown timeout exceeded, forcing exit")
		
		// Force close any remaining connections
		logger.Info("Force closing remaining connections")
		if hubManager.IsRunning() {
			logger.Warn("Hub manager still running, forcing shutdown")
		}
	}
	
	// Check for any shutdown errors
	select {
	case err := <-shutdownErrors:
		logger.WithField("error", err).Error("Shutdown completed with errors")
	default:
		logger.Info("Shutdown completed without errors")
	}
	
	logger.Info("Server exited")
}